"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _path = _interopRequireDefault(require("path"));

var t = _interopRequireWildcard(require("@babel/types"));

var _murmurhash3js = _interopRequireDefault(require("murmurhash3js"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// import blog from 'babel-log'
var isImportLocalName = function isImportLocalName(name, allowedNames, _ref) {
  var file = _ref.file;

  var isSearchedImportSpecifier = function isSearchedImportSpecifier(specifier) {
    return specifier.isImportSpecifier() && allowedNames.includes(specifier.node.imported.name) && specifier.node.local.name === name;
  };

  var isImported = false;
  file.path.traverse({
    ImportDeclaration: {
      exit(path) {
        isImported = path.node.source.value.includes('react-intl') && path.get('specifiers').some(isSearchedImportSpecifier);

        if (isImported) {
          path.stop();
        }
      }

    }
  });
  return isImported;
};

var REG = new RegExp(`\\${_path.default.sep}`, 'gu');

var dotPath = function dotPath(str) {
  return str.replace(REG, '.');
};

var getPrefix = function getPrefix(_ref2, exportName) {
  var filename = _ref2.file.opts.filename,
      _ref2$opts = _ref2.opts,
      removePrefix = _ref2$opts.removePrefix,
      _ref2$opts$filebase = _ref2$opts.filebase,
      filebase = _ref2$opts$filebase === void 0 ? false : _ref2$opts$filebase;

  if (removePrefix === true) {
    return exportName === null ? '' : exportName;
  }

  var file = _path.default.relative(process.cwd(), filename);

  var fomatted = filebase ? file.replace(/\.(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+$/, '') : _path.default.dirname(file);
  removePrefix = removePrefix === undefined || removePrefix === false ? '' : removePrefix;
  var fixed = removePrefix instanceof RegExp ? dotPath(fomatted.replace(removePrefix, '')) : dotPath(fomatted).replace(new RegExp(`^${removePrefix.replace(/\//g, '')}\\${dotPath(_path.default.sep)}?`, 'u'), '');

  if (exportName === null) {
    return fixed;
  }

  if (fixed === '') {
    return exportName;
  }

  return `${fixed}.${exportName}`;
};

var getId = function getId(path, prefix) {
  var name;

  if (path.isStringLiteral()) {
    name = path.node.value;
  } else if (path.isIdentifier()) {
    name = path.node.name;
  }

  if (!name) {
    throw new Error(`requires Object key or string literal`);
  }

  return dotPath(_path.default.join(prefix, name));
};

var isLiteral = function isLiteral(node) {
  return t.isStringLiteral(node) || t.isTemplateLiteral(node);
};

var isDefineMessagesCall = function isDefineMessagesCall(path, state) {
  var callee = path.get('callee');
  return callee.isIdentifier() && isImportLocalName(callee.node.name, ['defineMessages'], state) && Boolean(path.get('arguments.0'));
};

var getLeadingComment = function getLeadingComment(prop) {
  var commentNodes = prop.node.leadingComments;
  return commentNodes ? commentNodes.map(function (node) {
    return node.value.trim();
  }).join('\n') : null;
};

var objectProperty = function objectProperty(key, value) {
  var valueNode = typeof value === 'string' ? t.stringLiteral(value) : value;
  return t.objectProperty(t.stringLiteral(key), valueNode);
}; // eslint-disable-next-line max-lines-per-function


var replaceProperties = function replaceProperties(properties, state, exportName) {
  var prefix = getPrefix(state, exportName);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var prop = _step.value;
      var propValue = prop.get('value');
      var messageDescriptorProperties = []; // { defaultMessage: 'hello', description: 'this is hello' }

      if (propValue.isObjectExpression()) {
        var objProps = propValue.get('properties'); // { id: 'already has id', defaultMessage: 'hello' }

        var isNotHaveId = objProps.every(function (v) {
          return v.get('key').node.name !== 'id';
        });

        if (isNotHaveId) {
          var id = getId(prop.get('key'), prefix);
          messageDescriptorProperties.push(objectProperty('id', id));
        }

        messageDescriptorProperties.push.apply(messageDescriptorProperties, _toConsumableArray(objProps.map(function (v) {
          return v.node;
        })));
      } else if (isLiteral(propValue)) {
        // 'hello' or `hello ${user}`
        var _id = getId(prop.get('key'), prefix);

        messageDescriptorProperties.push(objectProperty('id', _id), objectProperty('defaultMessage', propValue.node));
      } else {
        var evaluated = prop.get('value').evaluate();

        if (evaluated.confident && typeof evaluated.value === 'string') {
          var _id2 = dotPath(_path.default.join(prefix, evaluated.value));

          messageDescriptorProperties.push(objectProperty('id', _id2), objectProperty('defaultMessage', propValue.node));
        }
      }

      var _state$opts$extractCo = state.opts.extractComments,
          extractComments = _state$opts$extractCo === void 0 ? true : _state$opts$extractCo;

      if (extractComments) {
        var hasDescription = messageDescriptorProperties.find(function (v) {
          return v.key.name === 'description';
        });

        if (!hasDescription) {
          var description = getLeadingComment(prop);

          if (description) {
            messageDescriptorProperties.push(objectProperty('description', description));
          }
        }
      }

      propValue.replaceWith(t.objectExpression(messageDescriptorProperties));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

var getExportName = function getExportName(path, includeExportName) {
  var namedExport = path.findParent(function (v) {
    return v.isExportNamedDeclaration();
  });
  var defaultExport = path.findParent(function (v) {
    return v.isExportDefaultDeclaration();
  });

  if (includeExportName && namedExport) {
    return namedExport.get('declaration.declarations.0.id.name').node;
  }

  if (includeExportName === 'all' && defaultExport) {
    return 'default';
  }

  return null;
};

function getProperties(path) {
  if (path.isObjectExpression()) {
    return path.get('properties');
  } else if (path.isIdentifier()) {
    var name = path.node.name;
    var obj = path.scope.getBinding(name);

    if (!obj) {
      return null;
    }

    return obj.path.get('init.properties');
  }

  return null;
} // Process react-intl components


var REACT_COMPONENTS = ['FormattedMessage', 'FormattedHTMLMessage'];

var getElementAttributePaths = function getElementAttributePaths(elementPath) {
  if (!elementPath) {
    return {};
  }

  var attributesPath = elementPath.get('attributes');
  var defaultMessagePath = attributesPath.find(function (attrPath) {
    return attrPath.node.name && attrPath.node.name.name === 'defaultMessage';
  });
  var idPath = attributesPath.find(function (attrPath) {
    return attrPath.node.name && attrPath.node.name.name === 'id';
  });
  var keyPath = attributesPath.find(function (attrPath) {
    return attrPath.node.name && attrPath.node.name.name === 'key';
  });
  return {
    id: idPath,
    defaultMessage: defaultMessagePath,
    key: keyPath
  };
};

var createHash = function createHash(message) {
  return `${_murmurhash3js.default.x86.hash32(message)}`;
};

var extractFromValuePath = function extractFromValuePath(valueObject) {
  if (!valueObject) {
    return null;
  }

  var valuePath = valueObject.get('value');

  if (valuePath) {
    if (valuePath.isStringLiteral()) {
      // Use the message as is if it's a string
      return valueObject.node.value.value;
    } // Evaluate the message expression to see if it yields a string


    var evaluated = valuePath.get('expression').evaluate();

    if (evaluated.confident && typeof evaluated.value === 'string') {
      return evaluated.value;
    }

    throw valuePath.buildCodeFrameError(`[React Intl Auto] ${valueObject.get('name').node.name} must be statically evaluate-able for extraction.`);
  }

  return null;
};

var generateId = function generateId(defaultMessage, state, key) {
  // ID = path to the file + key
  var suffix = state.opts.useKey ? extractFromValuePath(key) : '';

  if (!suffix) {
    // ID = path to the file + hash of the defaultMessage
    var messageValue = extractFromValuePath(defaultMessage);

    if (messageValue) {
      suffix = createHash(messageValue);
    }
  }

  var prefix = getPrefix(state, suffix); // Insert an id attribute before the defaultMessage attribute

  defaultMessage.insertBefore(t.jSXAttribute(t.jSXIdentifier('id'), t.stringLiteral(prefix)));
};

var visitJSXElement = function visitJSXElement(path, state) {
  var element = path.get('openingElement'); // Is this a react-intl component? Handles both:
  // import { FormattedMessage as T } from 'react-intl'
  // import { FormattedMessage } from 'react-intl'

  if (isImportLocalName(element.node.name.name, REACT_COMPONENTS, state)) {
    // Get the attributes for the component
    var _getElementAttributeP = getElementAttributePaths(element),
        id = _getElementAttributeP.id,
        defaultMessage = _getElementAttributeP.defaultMessage,
        key = _getElementAttributeP.key; // If valid message but missing ID, generate one


    if (!id && defaultMessage) {
      generateId(defaultMessage, state, state.opts.useKey ? key : null);
    }
  }
};

function _default() {
  return {
    name: 'react-intl-auto',
    visitor: {
      JSXElement: visitJSXElement,

      CallExpression(path, state) {
        if (!isDefineMessagesCall(path, state)) {
          return;
        }

        var properties = getProperties(path.get('arguments.0'));

        if (properties) {
          var exportName = getExportName(path, state.opts.includeExportName || false);
          replaceProperties(properties, state, exportName);
        }
      }

    }
  };
}